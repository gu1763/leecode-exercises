你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：

整数 x - 表示本回合新获得分数 x
"+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
"D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
"C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。

 //c
#include <stdlib.h>
#include <string.h> 	//要使用字符串处理方法

int calPoints(char** operations, int operationsSize) 
{
    int* scores = (int*)malloc(operationsSize * sizeof(int));	//创建数组存储每次的分数
    int top = -1; 					// 栈顶指针
    int sum = 0;
    
    for(int i = 0; i < operationsSize; i++)
    {
        if(strcmp(operations[i], "+") == 0) 			//operations是指针数组，其中的元素是指针，指向的是字符串
        {
            // 前两次得分的总和
            int newScore = scores[top] + scores[top-1];
            scores[++top] = newScore;			//将新一次的分数放到栈顶
        }
        else if(strcmp(operations[i], "D") == 0) 
        {
            // 前一次得分的两倍
            int newScore = scores[top] * 2;
            scores[++top] = newScore;			//同样放到栈顶
        }
        else if(strcmp(operations[i], "C") == 0) 
        {
            top--;					//移除前一次得分
        }
        else 
        {
            // 整数得分
            int score = atoi(operations[i]);			//转换类型
            scores[++top] = score;
        }
    }
    
    // 计算所有有效得分的总和，把栈中存储的每次操作变化的分数加起来
    for(int i = 0; i <= top; i++)
    {
        sum += scores[i];
    }
    
    free(scores);
    return sum;
}


//python   		//使用列表模拟栈的行为
class Solution:
    def calPoints(self, operations: List[str]) -> int:
        stack = []
    
        for op in operations:
            if op == "+":
                # 前两次得分的总和
                stack.append(stack[-1] + stack[-2])
            elif op == "D":
                # 前一次得分的两倍
                stack.append(stack[-1] * 2)
            elif op == "C":
            # 移除前一次得分
                stack.pop()
            else:
            # 整数得分
                stack.append(int(op))
        return sum(stack)