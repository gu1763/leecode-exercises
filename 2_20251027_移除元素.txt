/*给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。

假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：

更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
返回 k。
用户评测：

评测机将使用以下代码测试您的解决方案*/

int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
/*如果所有的断言都通过，你的解决方案将会 通过。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/array-and-string/cwuyj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/

int removeElement(int* nums, int numsSize, int val) 
{
    int *fast=nums;//快慢指针。
    int *slow=nums;
    int k=0;
    for(int i=0;i<numsSize;i++,fast++)
    {
        if(*fast!=val)//当*fast无需去除时把它赋给*slow，去除时则不进行操作，继续读取下一个*fast。
        {
            k++;
            *slow++=*fast;
        }
    }
    return k;
}
//很简单的快慢指针问题。