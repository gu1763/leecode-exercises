给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

 //c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* searchRange(int* nums, int numsSize, int target, int* returnSize) 
{
    *returnSize=2;
    int *ans=(int*)malloc(2*sizeof(int));
    if(numsSize==0)
    {
        ans[0]=-1,ans[1]=-1;
        return ans;
    }
    int l=0,r=numsSize-1,f=-1;
    while(l<=r)
    {
        int m=(l+r)/2;
        if(target==nums[m])
        {
            f=m;		//防止无法跳出循环
            break;
        }
        if(nums[m]>target) r=m-1;
        else l=m+1;
    }
    if(f==-1)
    {
        ans[0]=-1;
        ans[1]=-1;
        return ans;
    }
    l=f;
    while(l>=0&&nums[l]==target) l--;
    r=f;
    while(r<=numsSize-1&&nums[r]==target) r++;
    ans[0]=l+1;
    ans[1]=r-1;
    return ans;
}

int* searchRange(int* nums, int numsSize, int target, int* returnSize) 
{
    *returnSize=2;
    int *ans=(int*)malloc(2*sizeof(int));
    if(numsSize==0)
    {
        ans[0]=-1,ans[1]=-1;
        return ans;
    }
    int l=0,r=numsSize-1;
    while(r>l)
    {
        int m=(l+r)/2;
        if(nums[m]>=target) r=m;
        else l=m+1;
    }
    if(nums[l]!=target&&nums[r]!=target)
    {
        ans[0]=-1,ans[1]=-1;
        return ans;
    }
    while(l>=0&&nums[l]==target) l--;
    while(r<=numsSize-1&&nums[r]==target) r++;
    ans[0]=l+1;
    ans[1]=r-1;
    return ans;
}
法三，两次二分查找
int* searchRange(int* nums, int numsSize, int target, int* returnSize) 
{
    *returnSize = 2;
    int *ans = (int*)malloc(2 * sizeof(int));
    
    // 查找左边界
    int left = 0, right = numsSize - 1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    int first = (left < numsSize && nums[left] == target) ? left : -1;
    
    // 查找右边界
    left = 0, right = numsSize - 1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    int last = (right >= 0 && nums[right] == target) ? right : -1;
    
    ans[0] = first;
    ans[1] = last;
    return ans;
}