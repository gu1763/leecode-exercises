给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。

区间 i 的 右侧区间 是满足 startj >= endi，且 startj 最小 的区间 j。注意 i 可能等于 j 。

返回一个由每个区间 i 对应的 右侧区间 下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。

 //c 二分查找
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize) 
{
    *intervalsColSize=2;
    int *ans=(int*)malloc(intervalsSize*sizeof(int));
    *returnSize=intervalsSize;
    int index[intervalsSize];
    for(int i=0;i<intervalsSize;i++) index[i]=i;

    for(int i=0;i<intervalsSize;i++)
    {
        for(int j=i+1;j<intervalsSize;j++)
        {
            if(intervals[i][0]>intervals[j][0])
            {
                int t=index[i];
                index[i]=index[j];
                index[j]=t;
            }
        }
    }
    for(int i=0;i<intervalsSize;i++)
    {
        int t=intervals[i][1];
        int l=0,r=intervalsSize-1;
        while(r>l)
        {
            int m=(l+r)/2;
            if(intervals[index[m]][0]==t)
            {
                l=r=m;
                break;
            }
            if(intervals[index[m]][0]<t) l=m+1;
            else r=m;
        }
        if(intervals[index[r]][0]>=t) ans[i]=index[r];
        else ans[i]=-1;
    }    
    return ans;
}

//快速排序优化
#include <stdlib.h>

typedef struct {
    int start;
    int end;
    int index;
} Interval;

int compare(const void* a, const void* b) {
    return ((Interval*)a)->start - ((Interval*)b)->start;
}

int* findRightInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize) {
    *returnSize = intervalsSize;
    int* result = (int*)malloc(intervalsSize * sizeof(int));
    
    // 创建结构体数组
    Interval* arr = (Interval*)malloc(intervalsSize * sizeof(Interval));
    for(int i = 0; i < intervalsSize; i++) {
        arr[i].start = intervals[i][0];
        arr[i].end = intervals[i][1];
        arr[i].index = i;
    }
    
    // 排序
    qsort(arr, intervalsSize, sizeof(Interval), compare);
    
    // 对每个区间查找
    for(int i = 0; i < intervalsSize; i++) {
        int target = intervals[i][1];
        int left = 0, right = intervalsSize - 1;
        int found = -1;
        
        while(left <= right) {
            int mid = left + (right - left) / 2;
            
            if(arr[mid].start >= target) {
                found = arr[mid].index;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        result[i] = found;
    }
    
    free(arr);
    return result;
}