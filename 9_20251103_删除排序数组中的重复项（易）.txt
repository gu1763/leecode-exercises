/*删除排序数组中的重复项
给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k。去重后，返回唯一元素的数量 k。

nums 的前 k 个元素应包含 排序后 的唯一数字。下标 k - 1 之后的剩余元素可以忽略。

作者：LeetCode
链接：https://leetcode.cn/leetbook/read/array-and-string/cq376/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/

//使用快慢指针
int removeDuplicates(int* nums, int numsSize) 
{
    int *fast=nums;
    int *slow=nums;
    int i=1;
    while(++fast<=nums+numsSize-1)
    {
        if(*fast!=*(fast-1))	//当fast指向一个新的值，slow才会存住这个值。
        {
            *++slow=*fast;
            i++;
        }
    }
    return i;
}

//python
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:  # 处理空数组的情况
            return 0
            
        s = 1  # 慢指针，指向下一个不重复元素应该放置的位置
        
        for f in range(1, len(nums)):  # 快指针，遍历整个数组
            if nums[f] != nums[f-1]:   # 如果当前元素与前一个元素不同
                nums[s] = nums[f]      # 将不重复元素放到慢指针位置
                s += 1                 # 慢指针前进
        
        return s                       # 返回不重复元素的个数

//python3
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums:
            return 0
        s=1
        l=len(nums)
        for f in range(1,l):
            if(nums[f]!=nums[f-1]):
                nums[s]=nums[f]
                s=s+1
        return s        